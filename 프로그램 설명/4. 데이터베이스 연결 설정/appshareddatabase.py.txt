"""
Database connection and utility functions for YMV Business Management System
"""

import os
import logging
import pandas as pd
import psycopg2
from psycopg2.extras import RealDictCursor
from psycopg2.pool import SimpleConnectionPool
from contextlib import contextmanager
from typing import Dict, List, Optional, Any
import streamlit as st
from supabase import create_client, Client
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class DatabaseManager:
    """Database connection and query manager"""
    
    def __init__(self):
        self.supabase_url = os.getenv('SUPABASE_URL')
        self.supabase_key = os.getenv('SUPABASE_KEY')
        self.db_config = {
            'host': os.getenv('DB_HOST'),
            'port': os.getenv('DB_PORT', 5432),
            'database': os.getenv('DB_NAME'),
            'user': os.getenv('DB_USER'),
            'password': os.getenv('DB_PASSWORD'),
            'sslmode': 'require'
        }
        self.pool = None
        self.supabase_client = None
        self._initialize_connections()
    
    def _initialize_connections(self):
        """Initialize database connections"""
        try:
            # Initialize Supabase client
            if self.supabase_url and self.supabase_key:
                self.supabase_client = create_client(self.supabase_url, self.supabase_key)
                logger.info("Supabase client initialized successfully")
            
            # Initialize PostgreSQL connection pool
            self.pool = SimpleConnectionPool(
                minconn=1,
                maxconn=20,
                **self.db_config
            )
            logger.info("Database connection pool initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize database connections: {e}")
            st.error(f"Database connection failed: {e}")
    
    @contextmanager
    def get_connection(self):
        """Get database connection from pool"""
        conn = None
        try:
            conn = self.pool.getconn()
            yield conn
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Database error: {e}")
            raise
        finally:
            if conn:
                self.pool.putconn(conn)
    
    def execute_query(self, query: str, params: tuple = None, fetch: bool = True) -> Optional[List[Dict]]:
        """Execute SQL query and return results"""
        try:
            with self.get_connection() as conn:
                with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                    cursor.execute(query, params)
                    
                    if fetch:
                        results = cursor.fetchall()
                        return [dict(row) for row in results]
                    else:
                        conn.commit()
                        return None
                        
        except Exception as e:
            logger.error(f"Query execution failed: {e}")
            logger.error(f"Query: {query}")
            logger.error(f"Params: {params}")
            raise
    
    def execute_many(self, query: str, params_list: List[tuple]) -> bool:
        """Execute query with multiple parameter sets"""
        try:
            with self.get_connection() as conn:
                with conn.cursor() as cursor:
                    cursor.executemany(query, params_list)
                    conn.commit()
                    return True
        except Exception as e:
            logger.error(f"Batch execution failed: {e}")
            return False
    
    def fetch_dataframe(self, query: str, params: tuple = None) -> pd.DataFrame:
        """Fetch query results as pandas DataFrame"""
        try:
            with self.get_connection() as conn:
                df = pd.read_sql_query(query, conn, params=params)
                return df
        except Exception as e:
            logger.error(f"DataFrame fetch failed: {e}")
            return pd.DataFrame()
    
    def get_table_info(self, table_name: str) -> List[Dict]:
        """Get table column information"""
        query = """
        SELECT column_name, data_type, is_nullable, column_default
        FROM information_schema.columns
        WHERE table_name = %s
        ORDER BY ordinal_position
        """
        return self.execute_query(query, (table_name,))
    
    def backup_table_to_csv(self, table_name: str, file_path: str) -> bool:
        """Backup table data to CSV file"""
        try:
            query = f"SELECT * FROM {table_name}"
            df = self.fetch_dataframe(query)
            df.to_csv(file_path, index=False, encoding='utf-8-sig')
            logger.info(f"Table {table_name} backed up to {file_path}")
            return True
        except Exception as e:
            logger.error(f"Backup failed for table {table_name}: {e}")
            return False
    
    def restore_table_from_csv(self, table_name: str, file_path: str) -> bool:
        """Restore table data from CSV file"""
        try:
            df = pd.read_csv(file_path)
            
            # Get table columns
            columns_info = self.get_table_info(table_name)
            table_columns = [col['column_name'] for col in columns_info]
            
            # Filter DataFrame to match table columns
            df_filtered = df[[col for col in df.columns if col in table_columns]]
            
            # Convert DataFrame to list of tuples
            data_tuples = [tuple(row) for row in df_filtered.values]
            
            # Create INSERT query
            columns_str = ', '.join(df_filtered.columns)
            placeholders = ', '.join(['%s'] * len(df_filtered.columns))
            query = f"INSERT INTO {table_name} ({columns_str}) VALUES ({placeholders})"
            
            # Execute batch insert
            success = self.execute_many(query, data_tuples)
            
            if success:
                logger.info(f"Table {table_name} restored from {file_path}")
            
            return success
            
        except Exception as e:
            logger.error(f"Restore failed for table {table_name}: {e}")
            return False

# Global database manager instance
db_manager = DatabaseManager()

# Utility functions for common operations
def get_user_by_username(username: str) -> Optional[Dict]:
    """Get user by username"""
    query = "SELECT * FROM users WHERE username = %s AND status = 'active'"
    results = db_manager.execute_query(query, (username,))
    return results[0] if results else None

def get_user_permissions(user_id: int) -> List[Dict]:
    """Get user permissions"""
    query = """
    SELECT module_name, permission_type 
    FROM user_permissions 
    WHERE user_id = %s
    """
    return db_manager.execute_query(query, (user_id,))

def generate_document_number(doc_type: str, date_obj) -> str:
    """Generate document number with auto-increment"""
    year = date_obj.year
    month = date_obj.month
    day = date_obj.day
    
    # Get or create sequence record
    query_select = """
    SELECT last_number FROM document_sequences 
    WHERE document_type = %s AND year = %s AND month = %s AND day = %s
    """
    
    result = db_manager.execute_query(query_select, (doc_type, year, month, day))
    
    if result:
        # Update existing sequence
        new_number = result[0]['last_number'] + 1
        query_update = """
        UPDATE document_sequences 
        SET last_number = %s, updated_at = CURRENT_TIMESTAMP
        WHERE document_type = %s AND year = %s AND month = %s AND day = %s
        """
        db_manager.execute_query(query_update, (new_number, doc_type, year, month, day), fetch=False)
    else:
        # Create new sequence
        new_number = 1
        query_insert = """
        INSERT INTO document_sequences (document_type, year, month, day, last_number)
        VALUES (%s, %s, %s, %s, %s)
        """
        db_manager.execute_query(query_insert, (doc_type, year, month, day, new_number), fetch=False)
    
    # Format document number: YMV-Qyymmdd-001
    date_str = f"{year % 100:02d}{month:02d}{day:02d}"
    return f"YMV-{doc_type}{date_str}-{new_number:03d}"

def get_exchange_rate(currency: str, year: int) -> Optional[float]:
    """Get exchange rate for currency and year"""
    query = """
    SELECT rate_to_usd FROM exchange_rates 
    WHERE currency_code = %s AND year = %s AND is_active = true
    """
    result = db_manager.execute_query(query, (currency, year))
    return result[0]['rate_to_usd'] if result else None

def convert_currency(amount: float, from_currency: str, to_currency: str, year: int) -> float:
    """Convert amount between currencies using USD as base"""
    if from_currency == to_currency:
        return amount
    
    # Convert to USD first
    if from_currency == 'USD':
        usd_amount = amount
    else:
        from_rate = get_exchange_rate(from_currency, year)
        if not from_rate:
            return amount  # Return original if rate not found
        usd_amount = amount / from_rate
    
    # Convert from USD to target currency
    if to_currency == 'USD':
        return usd_amount
    else:
        to_rate = get_exchange_rate(to_currency, year)
        if not to_rate:
            return amount  # Return original if rate not found
        return usd_amount * to_rate

def format_currency(amount: float, currency: str = 'USD', show_currency: bool = True) -> str:
    """Format currency with thousand separators"""
    if amount is None:
        return "0"
    
    # Format with thousand separators
    formatted = f"{amount:,.2f}"
    
    if show_currency:
        currency_symbols = {
            'USD': '$',
            'VND': '₫',
            'KRW': '₩',
            'CNY': '¥',
            'THB': '฿',
            'JPY': '¥',
            'EUR': '€'
        }
        symbol = currency_symbols.get(currency, currency)
        
        if currency == 'VND':
            # For VND, show without decimal places
            formatted = f"{amount:,.0f}"
            return f"{formatted} {symbol}"
        else:
            return f"{symbol} {formatted}"
    
    return formatted

def log_audit(user_id: int, table_name: str, record_id: int, action: str, 
              old_values: Dict = None, new_values: Dict = None):
    """Log audit trail"""
    import json
    
    query = """
    INSERT INTO audit_logs (user_id, table_name, record_id, action, old_values, new_values)
    VALUES (%s, %s, %s, %s, %s, %s)
    """
    
    old_json = json.dumps(old_values) if old_values else None
    new_json = json.dumps(new_values) if new_values else None
    
    try:
        db_manager.execute_query(
            query, 
            (user_id, table_name, record_id, action, old_json, new_json), 
            fetch=False
        )
    except Exception as e:
        logger.error(f"Audit log failed: {e}")

def get_system_setting(key: str, default_value: Any = None) -> Any:
    """Get system setting value"""
    query = "SELECT setting_value, setting_type FROM system_settings WHERE setting_key = %s"
    result = db_manager.execute_query(query, (key,))
    
    if not result:
        return default_value
    
    value = result[0]['setting_value']
    setting_type = result[0]['setting_type']
    
    # Convert based on type
    if setting_type == 'number':
        try:
            return float(value) if '.' in value else int(value)
        except ValueError:
            return default_value
    elif setting_type == 'boolean':
        return value.lower() in ('true', '1', 'yes', 'on')
    elif setting_type == 'json':
        import json
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return default_value
    else:
        return value

def set_system_setting(key: str, value: Any, setting_type: str = 'string', user_id: int = None):
    """Set system setting value"""
    # Convert value to string
    if setting_type == 'json':
        import json
        str_value = json.dumps(value)
    elif setting_type == 'boolean':
        str_value = str(bool(value)).lower()
    else:
        str_value = str(value)
    
    query = """
    INSERT INTO system_settings (setting_key, setting_value, setting_type, updated_by)
    VALUES (%s, %s, %s, %s)
    ON CONFLICT (setting_key) 
    DO UPDATE SET 
        setting_value = EXCLUDED.setting_value,
        setting_type = EXCLUDED.setting_type,
        updated_by = EXCLUDED.updated_by,
        updated_at = CURRENT_TIMESTAMP
    """
    
    db_manager.execute_query(query, (key, str_value, setting_type, user_id), fetch=False)

# Connection test function
def test_connection() -> bool:
    """Test database connection"""
    try:
        query = "SELECT 1 as test"
        result = db_manager.execute_query(query)
        return bool(result)
    except Exception as e:
        logger.error(f"Connection test failed: {e}")
        return False