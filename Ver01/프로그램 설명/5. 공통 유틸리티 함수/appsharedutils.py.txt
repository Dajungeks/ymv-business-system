"""
Utility functions for YMV Business Management System
"""

import re
import os
import io
import hashlib
import secrets
import pandas as pd
import streamlit as st
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.pdfgen import canvas
import base64

def validate_email(email: str) -> bool:
    """Validate email format"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

def validate_phone(phone: str) -> bool:
    """Validate phone number format"""
    # Remove all non-digit characters
    digits_only = re.sub(r'\D', '', phone)
    # Check if it has 8-15 digits (international phone number range)
    return len(digits_only) >= 8 and len(digits_only) <= 15

def validate_business_number(business_number: str) -> bool:
    """Validate business registration number format"""
    if not business_number:
        return True  # Optional field
    
    # Remove all non-alphanumeric characters
    clean_number = re.sub(r'[^a-zA-Z0-9]', '', business_number)
    # Business number should be 6-20 alphanumeric characters
    return len(clean_number) >= 6 and len(clean_number) <= 20

def generate_password_hash(password: str) -> str:
    """Generate bcrypt hash for password"""
    import bcrypt
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    """Verify password against bcrypt hash"""
    import bcrypt
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def generate_secure_token(length: int = 32) -> str:
    """Generate secure random token"""
    return secrets.token_urlsafe(length)

def sanitize_filename(filename: str) -> str:
    """Sanitize filename for safe file operations"""
    # Remove or replace invalid characters
    filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
    # Remove leading/trailing spaces and dots
    filename = filename.strip(' .')
    # Limit length
    if len(filename) > 255:
        name, ext = os.path.splitext(filename)
        filename = name[:255-len(ext)] + ext
    
    return filename

def format_date(date_obj: Union[datetime, str], format_str: str = '%Y-%m-%d') -> str:
    """Format date object or string to specified format"""
    if isinstance(date_obj, str):
        try:
            date_obj = datetime.strptime(date_obj, '%Y-%m-%d')
        except ValueError:
            return date_obj
    
    if isinstance(date_obj, datetime):
        return date_obj.strftime(format_str)
    
    return str(date_obj)

def parse_date(date_str: str, format_str: str = '%Y-%m-%d') -> Optional[datetime]:
    """Parse date string to datetime object"""
    try:
        return datetime.strptime(date_str, format_str)
    except (ValueError, TypeError):
        return None

def get_date_range(period: str) -> tuple:
    """Get date range for common periods"""
    today = datetime.now().date()
    
    if period == 'today':
        return today, today
    elif period == 'yesterday':
        yesterday = today - timedelta(days=1)
        return yesterday, yesterday
    elif period == 'this_week':
        start = today - timedelta(days=today.weekday())
        return start, today
    elif period == 'last_week':
        start = today - timedelta(days=today.weekday() + 7)
        end = start + timedelta(days=6)
        return start, end
    elif period == 'this_month':
        start = today.replace(day=1)
        return start, today
    elif period == 'last_month':
        if today.month == 1:
            start = today.replace(year=today.year-1, month=12, day=1)
            end = today.replace(day=1) - timedelta(days=1)
        else:
            start = today.replace(month=today.month-1, day=1)
            end = today.replace(day=1) - timedelta(days=1)
        return start, end
    elif period == 'this_year':
        start = today.replace(month=1, day=1)
        return start, today
    elif period == 'last_year':
        start = today.replace(year=today.year-1, month=1, day=1)
        end = today.replace(year=today.year-1, month=12, day=31)
        return start, end
    else:
        return today, today

def calculate_age(birth_date: datetime) -> int:
    """Calculate age from birth date"""
    today = datetime.now().date()
    if isinstance(birth_date, datetime):
        birth_date = birth_date.date()
    
    age = today.year - birth_date.year
    if today.month < birth_date.month or (today.month == birth_date.month and today.day < birth_date.day):
        age -= 1
    
    return age

def calculate_working_days(start_date: datetime, end_date: datetime, holidays: List[datetime] = None) -> int:
    """Calculate working days between two dates (excluding weekends and holidays)"""
    if holidays is None:
        holidays = []
    
    # Convert to date objects if datetime
    if isinstance(start_date, datetime):
        start_date = start_date.date()
    if isinstance(end_date, datetime):
        end_date = end_date.date()
    
    # Convert holiday list to date objects
    holiday_dates = []
    for holiday in holidays:
        if isinstance(holiday, datetime):
            holiday_dates.append(holiday.date())
        else:
            holiday_dates.append(holiday)
    
    working_days = 0
    current_date = start_date
    
    while current_date <= end_date:
        # Monday = 0, Sunday = 6
        if current_date.weekday() < 5 and current_date not in holiday_dates:
            working_days += 1
        current_date += timedelta(days=1)
    
    return working_days

def export_to_excel(data: Dict[str, pd.DataFrame], filename: str = None) -> bytes:
    """Export multiple DataFrames to Excel file"""
    output = io.BytesIO()
    
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        for sheet_name, df in data.items():
            # Clean sheet name (Excel sheet name restrictions)
            clean_sheet_name = re.sub(r'[:\\/?*\[\]]', '_', sheet_name)[:31]
            df.to_excel(writer, sheet_name=clean_sheet_name, index=False)
            
            # Get workbook and worksheet
            workbook = writer.book
            worksheet = writer.sheets[clean_sheet_name]
            
            # Add formatting
            header_format = workbook.add_format({
                'bold': True,
                'text_wrap': True,
                'valign': 'top',
                'fg_color': '#D7E4BC',
                'border': 1
            })
            
            # Write headers with formatting
            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, header_format)
            
            # Auto-adjust column widths
            for i, col in enumerate(df.columns):
                max_length = max(
                    df[col].astype(str).map(len).max(),
                    len(str(col))
                )
                worksheet.set_column(i, i, min(max_length + 2, 50))
    
    output.seek(0)
    return output.getvalue()

def import_from_excel(file_content: bytes, sheet_name: str = None) -> pd.DataFrame:
    """Import DataFrame from Excel file"""
    try:
        if sheet_name:
            df = pd.read_excel(io.BytesIO(file_content), sheet_name=sheet_name)
        else:
            df = pd.read_excel(io.BytesIO(file_content))
        
        # Clean column names (remove extra spaces, special characters)
        df.columns = df.columns.str.strip()
        
        return df
    except Exception as e:
        st.error(f"Error importing Excel file: {str(e)}")
        return pd.DataFrame()

def create_pdf_report(title: str, data: List[Dict], filename: str = None) -> bytes:
    """Create PDF report from data"""
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    styles = getSampleStyleSheet()
    story = []
    
    # Title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1  # Center alignment
    )
    story.append(Paragraph(title, title_style))
    story.append(Spacer(1, 20))
    
    if data:
        # Convert data to table format
        headers = list(data[0].keys())
        table_data = [headers]
        
        for row in data:
            table_data.append([str(row.get(header, '')) for header in headers])
        
        # Create table
        table = Table(table_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        story.append(table)
    else:
        story.append(Paragraph("No data available", styles['Normal']))
    
    # Build PDF
    doc.build(story)
    buffer.seek(0)
    return buffer.getvalue()

def download_button(data: bytes, filename: str, mime_type: str, label: str = "Download"):
    """Create download button for binary data"""
    b64 = base64.b64encode(data).decode()
    href = f'<a href="data:{mime_type};base64,{b64}" download="{filename}">{label}</a>'
    st.markdown(href, unsafe_allow_html=True)

def show_dataframe_with_controls(df: pd.DataFrame, key: str = None) -> pd.DataFrame:
    """Show DataFrame with search, filter, and pagination controls"""
    if df.empty:
        st.info("No data available")
        return df
    
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        search_term = st.text_input("ðŸ” Search", key=f"{key}_search" if key else None)
    
    with col2:
        items_per_page = st.selectbox(
            "Items per page", 
            [10, 20, 50, 100], 
            index=1,
            key=f"{key}_items" if key else None
        )
    
    with col3:
        if st.button("ðŸ“„ Export CSV", key=f"{key}_export" if key else None):
            csv = df.to_csv(index=False)
            st.download_button(
                label="Download CSV",
                data=csv,
                file_name=f"export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                mime="text/csv"
            )
    
    # Apply search filter
    filtered_df = df.copy()
    if search_term:
        # Search across all string columns
        string_columns = df.select_dtypes(include=['object']).columns
        mask = df[string_columns].astype(str).apply(
            lambda x: x.str.contains(search_term, case=False, na=False)
        ).any(axis=1)
        filtered_df = df[mask]
    
    # Pagination
    total_rows = len(filtered_df)
    total_pages = (total_rows - 1) // items_per_page + 1 if total_rows > 0 else 1
    
    if total_pages > 1:
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col2:
            page = st.selectbox(
                f"Page (Total: {total_pages})",
                range(1, total_pages + 1),
                key=f"{key}_page" if key else None
            )
        
        start_idx = (page - 1) * items_per_page
        end_idx = start_idx + items_per_page
        page_df = filtered_df.iloc[start_idx:end_idx]
    else:
        page_df = filtered_df
    
    # Show info
    st.info(f"Showing {len(page_df)} of {total_rows} records")
    
    return page_df

def validate_required_fields(data: Dict, required_fields: List[str]) -> List[str]:
    """Validate required fields and return list of missing fields"""
    missing_fields = []
    for field in required_fields:
        if field not in data or not data[field] or (isinstance(data[field], str) and data[field].strip() == ''):
            missing_fields.append(field)
    return missing_fields

def clean_numeric_input(value: str) -> Optional[float]:
    """Clean and convert numeric input to float"""
    if not value:
        return None
    
    # Remove currency symbols and separators
    cleaned = re.sub(r'[^0-9.-]', '', str(value))
    
    try:
        return float(cleaned)
    except ValueError:
        return None

def generate_barcode_data(text: str) -> str:
    """Generate simple barcode representation (for display purposes)"""
    # This is a simplified barcode representation
    # In production, you might want to use a proper barcode library
    barcode_chars = 'â–ˆ â–Œâ–'
    result = ''
    
    for char in text:
        # Simple character to barcode mapping
        ascii_val = ord(char)
        pattern = format(ascii_val % 8, '03b')  # 3-bit pattern
        for bit in pattern:
            result += barcode_chars[int(bit)]
        result += ' '
    
    return result

def log_user_activity(user_id: int, action: str, details: str = None):
    """Log user activity for audit purposes"""
    from .database import db_manager
    
    try:
        query = """
        INSERT INTO audit_logs (user_id, table_name, action, new_values)
        VALUES (%s, 'user_activity', %s, %s)
        """
        
        activity_data = {
            'action': action,
            'details': details,
            'timestamp': datetime.now().isoformat(),
            'ip_address': get_client_ip()
        }
        
        import json
        db_manager.execute_query(
            query, 
            (user_id, action, json.dumps(activity_data)), 
            fetch=False
        )
    except Exception as e:
        # Don't raise exception for logging failures
        pass

def get_client_ip() -> str:
    """Get client IP address"""
    try:
        # Try to get real IP from headers (for proxy/load balancer setups)
        import streamlit as st
        
        # These are common headers set by proxies
        headers_to_check = [
            'X-Forwarded-For',
            'X-Real-IP', 
            'X-Client-IP',
            'CF-Connecting-IP'  # Cloudflare
        ]
        
        # This is a simplified approach - in production you'd want more robust IP detection
        return "127.0.0.1"  # Default for local development
        
    except Exception:
        return "unknown"

def create_notification(user_id: int, title: str, message: str, notification_type: str = 'info'):
    """Create user notification"""
    from .database import db_manager
    
    try:
        query = """
        INSERT INTO user_notifications (user_id, title, message, type, is_read)
        VALUES (%s, %s, %s, %s, false)
        """
        
        db_manager.execute_query(
            query, 
            (user_id, title, message, notification_type), 
            fetch=False
        )
    except Exception as e:
        # Create notifications table if it doesn't exist
        create_notifications_table()

def create_notifications_table():
    """Create notifications table if it doesn't exist"""
    from .database import db_manager
    
    query = """
    CREATE TABLE IF NOT EXISTS user_notifications (
        notification_id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
        title VARCHAR(200) NOT NULL,
        message TEXT,
        type VARCHAR(20) DEFAULT 'info' CHECK (type IN ('info', 'warning', 'error', 'success')),
        is_read BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """
    
    try:
        db_manager.execute_query(query, fetch=False)
        
        # Create index
        index_query = "CREATE INDEX IF NOT EXISTS idx_notifications_user_read ON user_notifications(user_id, is_read)"
        db_manager.execute_query(index_query, fetch=False)
        
    except Exception as e:
        pass

def get_user_notifications(user_id: int, unread_only: bool = False) -> List[Dict]:
    """Get user notifications"""
    from .database import db_manager
    
    query = """
    SELECT notification_id, title, message, type, is_read, created_at
    FROM user_notifications
    WHERE user_id = %s
    """
    
    params = [user_id]
    
    if unread_only:
        query += " AND is_read = false"
    
    query += " ORDER BY created_at DESC LIMIT 50"
    
    try:
        return db_manager.execute_query(query, tuple(params))
    except Exception:
        return []

def mark_notification_read(notification_id: int):
    """Mark notification as read"""
    from .database import db_manager
    
    query = "UPDATE user_notifications SET is_read = true WHERE notification_id = %s"
    
    try:
        db_manager.execute_query(query, (notification_id,), fetch=False)
    except Exception:
        pass

def get_dashboard_stats(user_id: int) -> Dict:
    """Get dashboard statistics"""
    from .database import db_manager
    
    stats = {
        'total_customers': 0,
        'active_quotations': 0,
        'pending_orders': 0,
        'monthly_sales': 0,
        'pending_purchases': 0,
        'cash_balance': 0
    }
    
    try:
        # Total customers
        result = db_manager.execute_query("SELECT COUNT(*) as count FROM customers WHERE is_active = true")
        stats['total_customers'] = result[0]['count'] if result else 0
        
        # Active quotations
        result = db_manager.execute_query(
            "SELECT COUNT(*) as count FROM quotations WHERE status IN ('draft', 'sent') AND valid_until >= CURRENT_DATE"
        )
        stats['active_quotations'] = result[0]['count'] if result else 0
        
        # Pending orders
        result = db_manager.execute_query(
            "SELECT COUNT(*) as count FROM orders WHERE status IN ('confirmed', 'in_progress')"
        )
        stats['pending_orders'] = result[0]['count'] if result else 0
        
        # Monthly sales (current month)
        result = db_manager.execute_query("""
            SELECT COALESCE(SUM(total_amount_usd), 0) as total
            FROM orders 
            WHERE EXTRACT(YEAR FROM order_date) = EXTRACT(YEAR FROM CURRENT_DATE)
            AND EXTRACT(MONTH FROM order_date) = EXTRACT(MONTH FROM CURRENT_DATE)
            AND status != 'cancelled'
        """)
        stats['monthly_sales'] = result[0]['total'] if result else 0
        
        # Pending purchases
        result = db_manager.execute_query(
            "SELECT COUNT(*) as count FROM purchases WHERE status IN ('draft', 'confirmed') AND payment_status != 'paid'"
        )
        stats['pending_purchases'] = result[0]['count'] if result else 0
        
        # Cash balance (simplified - sum of income minus expenses)
        result = db_manager.execute_query("""
            SELECT 
                COALESCE(SUM(CASE WHEN transaction_type = 'income' THEN amount_usd ELSE -amount_usd END), 0) as balance
            FROM cash_flows
            WHERE status = 'confirmed'
        """)
        stats['cash_balance'] = result[0]['balance'] if result else 0
        
    except Exception as e:
        # Return default stats if queries fail
        pass
    
    return stats

def create_backup_filename(table_name: str) -> str:
    """Create standardized backup filename"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    return f"backup_{table_name}_{timestamp}.csv"

def validate_csv_headers(df: pd.DataFrame, required_headers: List[str]) -> List[str]:
    """Validate CSV headers and return missing ones"""
    df_headers = [col.strip().lower() for col in df.columns]
    required_lower = [header.lower() for header in required_headers]
    
    missing = []
    for required in required_lower:
        if required not in df_headers:
            missing.append(required)
    
    return missing

def clean_dataframe_for_db(df: pd.DataFrame) -> pd.DataFrame:
    """Clean DataFrame for database insertion"""
    df_clean = df.copy()
    
    # Replace NaN with None
    df_clean = df_clean.where(pd.notnull(df_clean), None)
    
    # Strip whitespace from string columns
    string_columns = df_clean.select_dtypes(include=['object']).columns
    for col in string_columns:
        df_clean[col] = df_clean[col].astype(str).str.strip()
        # Replace 'nan' string with None
        df_clean[col] = df_clean[col].replace('nan', None)
    
    # Convert empty strings to None
    df_clean = df_clean.replace('', None)
    
    return df_clean

def format_file_size(size_bytes: int) -> str:
    """Format file size in human readable format"""
    if size_bytes == 0:
        return "0 B"
    
    size_names = ["B", "KB", "MB", "GB", "TB"]
    import math
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    
    return f"{s} {size_names[i]}"

def is_valid_file_type(filename: str, allowed_extensions: List[str]) -> bool:
    """Check if file type is allowed"""
    if not filename:
        return False
    
    file_ext = filename.lower().split('.')[-1]
    return file_ext in [ext.lower() for ext in allowed_extensions]

def create_sample_data_download() -> bytes:
    """Create sample data template for CSV import"""
    sample_data = {
        'customers': pd.DataFrame({
            'company_name': ['Sample Company Ltd.', 'Another Corp.'],
            'contact_person': ['John Doe', 'Jane Smith'],
            'phone': ['+84-123-456-789', '+84-987-654-321'],
            'email': ['john@sample.com', 'jane@another.com'],
            'address': ['123 Sample St, Ho Chi Minh City', '456 Another Ave, Hanoi'],
            'country': ['Vietnam', 'Vietnam'],
            'customer_type': ['corporate', 'corporate'],
            'payment_terms': [30, 15]
        }),
        'products': pd.DataFrame({
            'product_code': ['PROD-001', 'PROD-002'],
            'product_name_en': ['Sample Product 1', 'Sample Product 2'],
            'product_name_ko': ['ìƒ˜í”Œ ì œí’ˆ 1', 'ìƒ˜í”Œ ì œí’ˆ 2'],
            'product_name_vn': ['Sáº£n pháº©m máº«u 1', 'Sáº£n pháº©m máº«u 2'],
            'specification': ['Sample specification', 'Another specification'],
            'unit': ['ea', 'kg'],
            'cost_price': [100.00, 250.00],
            'selling_price_usd': [150.00, 350.00]
        })
    }
    
    return export_to_excel(sample_data, 'sample_data_template.xlsx')

# Error handling decorators
def handle_db_errors(func):
    """Decorator to handle database errors gracefully"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            st.error(f"Database error: {str(e)}")
            return None
    return wrapper

def handle_file_errors(func):
    """Decorator to handle file operation errors"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            st.error(f"File operation error: {str(e)}")
            return None
    return wrapper

# Custom exceptions
class ValidationError(Exception):
    """Custom validation error"""
    pass

class DatabaseError(Exception):
    """Custom database error"""
    pass

class FileProcessingError(Exception):
    """Custom file processing error"""
    pass

# Session state helpers
def init_session_state():
    """Initialize session state variables"""
    if 'user_id' not in st.session_state:
        st.session_state.user_id = None
    if 'username' not in st.session_state:
        st.session_state.username = None
    if 'user_permissions' not in st.session_state:
        st.session_state.user_permissions = {}
    if 'language' not in st.session_state:
        st.session_state.language = 'ko'
    if 'current_page' not in st.session_state:
        st.session_state.current_page = 'dashboard'

def clear_session_state():
    """Clear session state on logout"""
    keys_to_keep = ['language']  # Keep language setting
    keys_to_remove = [key for key in st.session_state.keys() if key not in keys_to_keep]
    
    for key in keys_to_remove:
        del st.session_state[key]

def check_user_permission(module: str, permission_type: str = 'read') -> bool:
    """Check if current user has permission for module"""
    if not st.session_state.get('user_id'):
        return False
    
    permissions = st.session_state.get('user_permissions', {})
    
    # Master user has all permissions
    if st.session_state.get('username') == 'Master':
        return True
    
    # Check specific permission
    module_permissions = permissions.get(module, [])
    
    # Admin permission grants all access to module
    if 'admin' in module_permissions:
        return True
    
    # Check specific permission type
    return permission_type in module_permissions

def require_permission(module: str, permission_type: str = 'read'):
    """Decorator to require specific permission"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            if not check_user_permission(module, permission_type):
                st.error("You don't have permission to access this feature.")
                st.stop()
            return func(*args, **kwargs)
        return wrapper
    return decorator