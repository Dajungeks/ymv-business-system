📌 프로그램 개발 진행 규칙 (AI 안내용) - V09
Program Development Rules for AI Guidance - V09

===========================================
한글 버전 (Korean Version)
===========================================

1. 설명 방식
- ERP 개발 전문가로서 효율적이고 사용하기 편리한 코드를 작성해야 함.
- 설명은 코딩 경험이 없는 일반 사용자도 이해할 수 있도록 쉬운 언어로 단계별 안내.

2. 코드 제공
- 항상 전체 코드(파일 단위)를 제공해야 함.
- 일부 코드만 수정하지 말고, 오류 가능성을 줄이기 위해 완전한 코드 블록으로 제시.

3. 수정 방식
- 수정 시, 수정이 필요한 위치와 적용 예시를 함께 제시.
- 부분 코드 대신 해당 함수 또는 파일 전체를 제공해야 함.

4. 작업 단계 진행
- 모든 작업은 Step 단위로 진행.
- 각 Step은 사용자가 최종 확인 후 다음 단계로 넘어감.

5. 개선 방향
- 개선 방법은 여러 개가 아닌, 현재 구조에 가장 적합한 1가지 방법만 제안.

6. 수정 안정성
- 세부 코드 조각 수정은 피하고, 오류 방지를 위해 항상 전체 함수 단위로 재작성.

7. 작업 완료 처리
- 저장, 삭제, 수정 등의 작업 후에는 완료 메시지 출력.
- 기존 입력창은 초기화 상태로 리셋되어야 함.

8. 문제 해결 방식
- 추측으로 코드 수정하지 않음.
- 문제가 의심되는 부분은 반드시 사용자에게 코드 요청 후 확인, 그 다음 해결책 제시.

9. 코드 최적화
- 모든 코딩을 최대한 짧은 길이로 만들기 위해서 components 구조 최대 활용.
- main.py 파일 크기 최소화를 위해 기능별로 컴포넌트 분리.

10. 자료 백업 및 연속성 보장
- 개발 세션 종료 시 .md 파일 생성 필수
- 다음 채팅창에서 문제 없이 개발하기 위해 다음 정보를 포함:
  * 시스템 현황: 파일 구조, 완성된 기능, 현재 문제점
  * 함수 리스트: 각 파일별 주요 함수와 역할 설명
  * DB 구조: 테이블 스키마, 관계도, 데이터 현황
  * 개발 진행사항: 이번 세션에서 완료/수정된 내용
  * 다음 단계: 우선순위별 개발 계획
  * AI 판단 추가 정보: 기술적 고려사항, 주의점
  * main.py 함수 호출 및 작성 방식 예시

11. 백업 파일 요청 방법
- 사용자 요청어: "규칙 10에 따라 백업 파일을 만들어줘"
- 또는: "다음 채팅에서 개발을 계속할 수 있도록 백업해줘"
- AI는 즉시 종합 백업 문서를 .md 형식으로 생성

12. 백업 파일 활용 방법
- 새 채팅창에서 백업 파일 업로드 후
- "이 백업 파일을 기반으로 개발을 계속해줘" 요청
- AI는 백업 내용을 분석하여 즉시 개발 재개 가능

13. 문제가 발생하거나 선택이 필요한 상황이 생기면, 나에게 선택을 요구하지 말고 현재 상황에서 가장 합리적이고 효율적인 단 하나의 해결책만 제시해야 한다.

14. main.py 함수 작성 및 호출
- main.py 내 함수는 호출 구조와 작성 방식을 반드시 백업에 포함해야 함.
- 각 함수의 정의, 입력값, 출력값, 호출 예시를 정리하여 기록.
- 함수 호출 흐름도를 함께 기록하여 개발 연속성 보장.
- 각 함수가 main.py 내에서 어떻게 호출되는지, 호출 순서 및 조건을 백업 파일에 상세히 기록해야 함.

15. 임포트(import) 문 규칙
- 임포트는 항상 파일의 최상단에 위치해야 함.
- 표준 라이브러리 → 서드파티 라이브러리 → 내부 모듈 순서로 정렬.
- 사용하지 않는 임포트는 절대 포함하지 말 것.
- `from module import *` 방식은 금지하고, 필요한 함수/클래스만 명시적으로 임포트.
- 가독성을 위해 동일한 그룹 간에는 한 줄 공백을 삽입.
- 백업 시 main.py 및 각 모듈별 임포트 목록을 반드시 기록해야 하며, 호출 의존성을 설명해야 함.

16. 추가 함수와 컴포넌트 관계 정리
- 새로운 함수를 작성할 때 반드시 어떤 컴포넌트와 연계되는지 기록해야 함.
- 함수는 독립적으로 작성하되, 호출되는 위치(메인 or 특정 컴포넌트)를 명확히 정의해야 함.
- 컴포넌트 간 의존성이 생길 경우, 데이터 흐름(입력/출력)을 간단히 다이어그램 또는 표로 기록.
- 백업 파일에는 “함수명 → 연결된 컴포넌트 → 호출 위치 → 반환 데이터” 구조로 정리해야 함.
- 동일한 기능을 중복 작성하지 않고, 컴포넌트 구조를 최대한 활용하도록 설계.

17. 오류 관리 및 해결 방식 정리
- 개발 중 발생한 오류는 반드시 세부 내용(에러 메시지, 원인, 수정 내역)을 기록해야 함.
- 동일 오류가 재발할 경우, 기존 해결 방식을 참고하여 빠르게 해결할 수 있도록 백업 파일에 포함.
- 오류 목록은 “오류명 → 발생 상황 → 원인 → 해결 방법 → 참고 코드” 구조로 정리.
- 백업 시 모든 오류 내역을 지속적으로 축적하여 문제 해결 가이드로 활용.

18. ConnectionWrapper 클래스 관리
- 데이터베이스 연결은 반드시 `ConnectionWrapper` 클래스를 통해 관리해야 함.
- `ConnectionWrapper` 클래스는 연결 생성, 커서 관리, 예외 처리, 연결 종료까지 책임져야 함.
- 직접 DB 커넥션을 호출하지 않고, 항상 `ConnectionWrapper`를 거쳐야 안정성을 보장할 수 있음.
- 백업 시 `ConnectionWrapper`의 구조(메서드, 예외 처리 방식)와 main.py 및 각 컴포넌트에서 어떻게 호출되는지 기록해야 함.
- 에러 발생 시 `ConnectionWrapper` 내 로그 기록 및 예외 재전달 방식을 문서화해야 함.

19. 호출 방식 관리
- 모든 함수와 클래스가 실제 코드에서 어떻게 호출되는지(순서, 조건, 위치)를 반드시 문서화해야 함.
- main.py 및 각 컴포넌트에서 함수가 불리는 시점과 흐름을 정리해야 함.
- 호출 시 전달되는 매개변수와 반환값도 함께 기록해야 함.
- 호출 흐름은 순서도(Flowchart) 또는 표로 정리하여 가독성을 높임.
- 백업 파일에는 “함수명/클래스명 → 호출 위치 → 호출 조건 → 전달 매개변수 → 반환 데이터” 구조로 반드시 기록.

20. DB 수정 우선 원칙
- 문제 해결 시 가능하다면 코드 수정보다 DB 수정을 우선 고려해야 함.
- 스키마, 관계, 제약 조건 등 DB 구조에서 해결 가능한 경우에는 코드 변경을 최소화해야 함.
- DB 수정 내역은 반드시 백업 파일에 기록해야 함.

21. 코딩 승인 절차
- 코딩 작업을 시작하기 전, AI는 먼저 수정·추가할 내용을 설명해야 함.
- 사용자가 설명을 확인하고 승인한 경우에만 실제 코드를 작성.
- 설명 단계에서는 코드 블록을 제시하지 않고, 흐름과 방법을 쉽게 이해할 수 있도록 설명 위주로 진행.

===========================================
English Version
===========================================

1. Explanation Style
- Write efficient and user-friendly code as an ERP expert.
- Explain in simple, step-by-step language so that even non-programmers can understand.

2. Code Provision
- Always provide the entire code (file-level).
- Do not provide partial snippets. To minimize errors, always provide complete code blocks.

3. Modification Method
- When modifying, clearly explain which part needs changes and show examples.
- Instead of partial edits, always provide the full function or file.

4. Step-by-Step Process
- All work must proceed in Steps.
- Each Step only continues after the user confirms completion.

5. Improvement Direction
- Do not provide multiple options. Only suggest one best solution that fits the current structure.

6. Stability in Edits
- Avoid modifying tiny fragments. Always rewrite at the function level (or higher) to ensure stability.

7. Completion Handling
- After actions like save, delete, or update, always print a completion message.
- Reset input fields back to default (empty) state after completion.

8. Problem-Solving Method
- Do not guess or assume fixes.
- If an issue is suspected, always request the relevant code from the user first, then provide a verified solution.

9. Code Optimization
- To keep code concise, maximize the use of components structure.
- Minimize main.py file size by separating functions into components.

10. Data Backup and Continuity Assurance
- Must generate .md backup file at the end of development sessions
- Include the following information for seamless development continuation:
  * System Status: file structure, completed features, current issues
  * Function List: major functions and roles in each file
  * DB Structure: table schemas, relationships, data status
  * Development Progress: completed/modified content in this session
  * Next Steps: development plans by priority
  * AI Additional Info: technical considerations, important notes
  * main.py function definitions, parameters, return values, and call examples

11. Backup File Request Method
- User request phrase: "Create a backup file according to rule 10"
- Or: "Create a backup so I can continue development in the next chat"
- AI immediately generates comprehensive backup document in .md format

12. Backup File Usage Method
- Upload backup file in new chat session
- Request: "Continue development based on this backup file"
- AI analyzes backup content and can immediately resume development

13. When a problem or decision point arises, do not ask me to choose. Always propose only one solution — the most reasonable and efficient option for the current situation.

14. main.py Functions Writing and Calling
- Backups must include how functions in main.py are defined and called.
- Record each function’s definition, input values, return values, and call examples.
- Document function call flowcharts to ensure development continuity.
- Backups must also include how each function in main.py is invoked, including call order and conditions.

15. Import Statement Rules
- Always place import statements at the top of the file.
- Order imports as: standard libraries → third-party libraries → internal modules.
- Never include unused imports.
- Avoid `from module import *`; explicitly import only what is needed.
- Add a blank line between different import groups for readability.
- In backups, always record the import list of main.py and each module, with explanations of their dependencies.

16. Relationship Between Additional Functions and Components
- When creating a new function, always document which component it is linked to.
- Functions should be written independently, but the calling location (main or specific component) must be clearly defined.
- If dependencies exist between components, record the data flow (inputs/outputs) with a simple diagram or table.
- In backups, document the structure as: Function → Linked Component → Call Location → Return Data.
- Avoid duplicate functionality; maximize reuse of existing components.

17. Error Management and Resolution Documentation
- All errors encountered during development must be documented with details (error messages, cause, fix applied).
- If the same error reoccurs, refer to the previous solution to resolve quickly; include this in backup files.
- Error logs must follow the structure: Error Name → Context → Cause → Resolution → Reference Code.
- Continuously accumulate error records in backups to serve as a troubleshooting guide.

18. ConnectionWrapper Class Management
- All database connections must be handled exclusively through the `ConnectionWrapper` class.
- The `ConnectionWrapper` class is responsible for connection creation, cursor management, error handling, and connection closing.
- Direct DB connections should never be used; always go through `ConnectionWrapper` for stability.
- In backups, document the structure of `ConnectionWrapper` (methods, error handling) and how it is invoked in main.py and each component.
- Error handling must include logging within `ConnectionWrapper` and re-throwing exceptions in a controlled manner.

19. Call Flow Management
- All functions and classes must have their call sequence, conditions, and locations documented.
- Document when and where each function is called in main.py and components.
- Include both parameters passed during calls and the return values.
- Represent the call flow using a flowchart or structured table for clarity.
- In backups, always record the structure as: Function/Class → Call Location → Call Condition → Passed Parameters → Returned Data.

20. DB Modification Priority
- When resolving issues, prioritize database modifications over code changes whenever possible.
- If the schema, relationships, or constraints can address the issue, minimize code changes.
- All DB modifications must be recorded in backup files.

21. Coding Approval Procedure
- Before starting any coding task, AI must first explain the planned changes or additions.
- Only after the user approves the explanation should the actual code be written.
- During the explanation stage, do not present code blocks; focus on explaining the logic and approach in simple terms.

